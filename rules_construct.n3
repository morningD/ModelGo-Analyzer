@prefix math: <http://www.w3.org/2000/10/swap/math#> .
@prefix list: <http://www.w3.org/2000/10/swap/list#> .
@prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#> .
@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix string: <http://www.w3.org/2000/10/swap/string#> .
@prefix log: <http://www.w3.org/2000/10/swap/log#> .
@prefix mg: <http://www.modelgo.li/rdf/terms#> .
@prefix xsd: <http://www.w3.org/2001/XMLSchema#> .
@prefix : <http://example.org/ns#>.


####    ML workflow eatablishing rules  ####

# An MG work has the same work type and form as its provenance work, if it exists.
{
    ?work a mg:Work .
    ?work mg:hasProvenance ?pwork .
    ?pwork mg:hasWorkType ?wtype .
    ?pwork mg:hasWorkForm ?wform .
} => {
    ?work mg:hasWorkType ?wtype .
    ?work mg:hasWorkForm ?wform .
} .

# Mixworks relationship proliferation. (Chain rule)
{
    ?work a mg:Work .
    ?work!mg:hasMixwork mg:hasMixwork ?mmixw .
} => {
    ?work mg:hasMixwork ?mmixw .
} .

# Add the 'hasSubwork' property to the output if 'targetSubwork' is provided through the input.
{
    ?action a mg:Action .
    ?action!mg:hasInput mg:targetSubwork ?work .
    ?action!mg:hasOutput mg:targetWork ?output .
} => {
    ?output mg:hasSubwork ?work .
} .
# Add the 'hasAuxwork' property to the output.
{
    ?action a mg:Action .
    ?action!mg:hasInput mg:targetAuxwork ?work .
    ?action!mg:hasOutput mg:targetWork ?output .
} => {
    ?output mg:hasAuxwork ?work .
} .

# Add the TargetWork from hasOutput to the next action's hasInput if "yieldAsInputWork" is provided.
{
    ?action a mg:Action .
    ?action mg:yieldAsInputWork ?next_action .
    ?action!mg:hasOutput mg:targetWork ?work .
    ?next_action mg:hasInput ?input .
} => {
    ?input mg:targetWork ?work .
} .

# Add the TargetAuxwork from hasOutput to the next action's hasInput->targetAuxwork if "yieldAsAuxwork" is provided.
{
    ?action a mg:Action .
    ?action mg:yieldAsAuxwork ?next_action .
    ?action!mg:hasOutput mg:targetWork ?work .
    ?next_action mg:hasInput ?input .
} => {
    ?input mg:targetAuxwork ?work .
} .

# Add the TargetSubwork from hasOutput to the next action's hasInput if "yieldAsSubWork" is provided.
{
    ?action a mg:Action .
    ?action mg:yieldAsSubWork ?next_action .
    ?action!mg:hasOutput mg:targetWork ?work .
    ?next_action mg:hasInput ?input .
} => {
    ?input mg:targetSubwork ?work .
} .

# Output work name assignment. We use a simplier name method instead.
{
    ?action a mg:Action .
    ?action mg:actionId ?aid .
    ?action!mg:hasOutput mg:targetWork ?outwork . # Note: We have not yet considered the case of multiple output works
    (?aid "_outwork")string:concatenation ?new_name .
} => {
    ?outwork mg:workName ?new_name .
} .


####   Action Reasoning rules  ####

##   ResiterLicense
# [ResiterLicense] Reasoning rules for registering a license to a work, which
# adds the 'hasProvenance' and 'hasLicense' properties to the output.
{
    ?action a mg:RegisterLicense . # Logical rule
    ?action!mg:hasInput mg:targetWork ?inw .
    ?action!mg:hasInput mg:targetLicense ?license .
    (?action "outputWork") log:skolem ?geniri . 
} => {
    ?geniri a mg:Work ; # Generate the hasOutput property
        mg:hasProvenance ?inw ;
        mg:hasLicense ?license ;
        mg:hasLicenseSource mg:license_source_register .
    ?action!mg:hasOutput mg:targetWork ?geniri .
} .

##   Copy
# [Copy] Reasoning rules for copying a work, which
# adds the 'hasMixwork' property to the output.
{
    ?action a mg:Copy .
    ?action!mg:hasInput mg:targetWork ?inw .
    ?action mg:hasOutput ?out .
    ?inw mg:hasWorkForm ?wf .
    ?inw mg:hasWorkType ?wt .
    ?inw mg:hasLicenseInfo ?linfo .
    (?action "outputWork") log:skolem ?geniri . 
} => {
    ?geniri a mg:Work ; # Hold same work form, type, and license info as the input work
        mg:hasMixwork ?inw ;
        mg:hasWorkForm ?wf ;
        mg:hasWorkType ?wt ;
        mg:hasLicenseInfo ?linfo .
    ?out mg:targetWork ?geniri .
} .

##   Modify
# [Modify] Reasoning rules for modify a work, which
# adds the 'hasMixwork' property to the output.
{
    ?action a mg:Modify .
    ?action!mg:hasInput mg:targetWork ?inw .
    ?action mg:hasOutput ?out .
    ?inw mg:hasWorkForm ?wf .
    ?inw mg:hasWorkType ?wt .
    (?action "outputWork") log:skolem ?geniri . 
} => {
    ?geniri a mg:Work ; # Hold same work form, type, and license info as the input work
        mg:hasMixwork ?inw ;
        mg:hasWorkForm ?wf ;
        mg:hasWorkType ?wt .
    ?out mg:targetWork ?geniri .
} .

##   Train
# [Train] Reasoning rules for training a model, which adds the 'hasMixwork' property to targetWork,
# and the output work has same type and form as the input target work.
{
    ?action a mg:Train .
    ?action!mg:hasInput mg:targetWork ?inw .
    ?action mg:hasOutput ?out .
    ?inw mg:hasWorkType ?wt .
    ?inw mg:hasWorkForm ?wf .
    (?action "outputWork") log:skolem ?geniri . # Only one unique output work is created for each train
} => {
    ?geniri a mg:Work ;
        mg:hasWorkType ?wt ;
        mg:hasWorkForm ?wf ;
        mg:hasMixwork ?inw .
    ?out mg:targetWork ?geniri .
} .

##   Combine
# [Combine] Reasoning rules for combine multiple works, which
# creates a new output work and adds the 'hasMixwork' to this output.
{
    ?action a mg:Combine .
    ?action!mg:hasInput mg:targetWork ?inw .
    ?action mg:hasOutput ?out .
    # We use log:skolem to ensure that just one targetWork is created for each combine case.
    (?action "outputWork") log:skolem ?geniri . 
} => {
    ?out mg:targetWork ?geniri .
    ?geniri a mg:Work ;
        mg:hasMixwork ?inw .
} .

# [Combine] Reasoning rules for determination the type and form of output work.
{ # Type, all same
    ?action a mg:Combine .
    ?action!mg:hasOutput mg:targetWork ?outw .
    ( ?t { ?action!mg:hasInput!mg:targetWork mg:hasWorkType ?t } ?t_list ) log:collectAllIn _:x .
    ({?t_list list:first ?t1 . ?t2 list:in ?t_list} {?t1 log:equalTo ?t2}) log:forAllIn _:x . # All type are same
    ?t_list list:first ?t1 .
} => {
    ?outw mg:hasWorkType ?t1 .
} .
{   # Type, not same
    ?action a mg:Combine .
    ?action!mg:hasOutput mg:targetWork ?outw .
    ( ?t { ?action!mg:hasInput!mg:targetWork mg:hasWorkType ?t } ?t_list ) log:collectAllIn _:x .
    ?t_list list:first ?t1 .
    ?t_list list:member ?t2 .
    _:t log:includes {?t1 log:notEqualTo ?t2 } .
} => {
    ?outw mg:hasWorkType mg:mixed-type .
} .

{ # Collect all input works' forms and broader forms ######## Need simplify
    ?action a mg:Combine .
    ?action!mg:hasInput mg:targetWork ?inw .
    ?inw mg:hasWorkForm ?f .
    ?f mg:broader ?bf .
    (?action "forms") log:skolem ?gen1 .
    (?action "broader_forms") log:skolem ?gen2 .
} => {
    ?gen1 mg:is ?f.
    ?gen2 mg:is ?bf.
} .
{  # Single work form case;
    ?action a mg:Combine .
    ?action!mg:hasOutput mg:targetWork ?outw .
    (?action "forms") log:skolem ?gen1 .
    ( ?f { ?gen1 mg:is ?f . } ?forms ) log:collectAllIn _:x .
    ?forms list:length ?len .
    ?len math:equalTo "1"^^<xsd:int> . # Only one input work form
    ?forms list:first ?form .
} => {
    ?outw mg:hasWorkForm ?form .
} . 
{ # Else, try to use the common broader form
    ?action a mg:Combine .
    ?action!mg:hasOutput mg:targetWork ?outw .
    (?action "forms") log:skolem ?gen1 .
    ( ?f { ?gen1 mg:is ?f . } ?forms ) log:collectAllIn _:x .
    ?forms list:length ?len1 .
    ?len1 math:greaterThan "1"^^<xsd:int> . # More than one input work form
    (?action "broader_forms") log:skolem ?gen2 .
    ( ?bf { ?gen2 mg:is ?bf . } ?bforms ) log:collectAllIn _:x .
    ?bforms list:length ?len2 .
    ?len2 math:equalTo "1"^^<xsd:int> . # Only one boarder form
    ?bforms list:first ?bform .
} => {
    ?outw mg:hasWorkForm ?bform .
} . 
{ # Else, if there is more than one broader form, use a mixed form
    ?action a mg:Combine .
    ?action!mg:hasOutput mg:targetWork ?outw .
    (?action "forms") log:skolem ?gen1 .
    ( ?f { ?gen1 mg:is ?f . } ?forms ) log:collectAllIn _:x .
    ?forms list:length ?len1 .
    ?len1 math:greaterThan "1"^^<xsd:int> . # More than one input work form
    (?action "broader_forms") log:skolem ?gen2 .
    ( ?bf { ?gen2 mg:is ?bf . } ?bforms ) log:collectAllIn _:x .
    ?bforms list:length ?len2 .
    ?len2 math:greaterThan "1"^^<xsd:int> . # More than one boarder form
} => {
    ?outw mg:hasWorkForm mg:mixed-form .
} .

##   Amalgamate
# [Amalgamate] Reasoning rules for amalgamate multiple works, which
# creates a new output work and adds the 'hasMixwork' to this output.
{
    ?action a mg:Amalgamate .
    ?action!mg:hasInput mg:targetWork ?inw .
    ?action mg:hasOutput ?out .
    (?w {?inw a mg:Work} ?w_list) log:collectAllIn _:t .
    ?w_list!list:first mg:hasWorkType ?wt . # Select the first input work's type and form for output work
    ?w_list!list:first mg:hasWorkForm ?wf .
    # We use log:skolem to ensure that just one targetWork is created for each combine case.
    (?action "outputWork") log:skolem ?geniri . 
} => {
    ?out mg:targetWork ?geniri .
    ?geniri a mg:Work ;
        mg:hasWorkType ?wt ;
        mg:hasWorkForm ?wf ;
        mg:hasMixwork ?inw .
} .

##   Embed
# [Embed] Reasoning rules for embed data (or something unknown), which adds the 'hasSubwork' property to targetWork,
# and the output work has same type and form as the input target work.
{
    ?action a mg:Embed . # Key difference
    ?action!mg:hasInput mg:targetWork ?inw .
    ?action mg:hasOutput ?out .
    ?inw mg:hasWorkType ?wt .
    ?inw mg:hasWorkForm ?wf .
    (?action "outputWork") log:skolem ?geniri . # Only one unique output work is created for each train
} => {
    ?out mg:targetWork ?geniri .
    ?geniri a mg:Work ;
        mg:hasWorkType ?wt ;
        mg:hasWorkForm ?wf ;
        mg:hasSubwork ?inw . # Key difference
} .

##   Distill
# [Distill] Reasoning rules for distill knowledge from a model to another, which adds the 'hasAubwork' property to targetWork,
# and the output work has same type and form as the input target work.
{
    ?action a mg:Distill . # Key difference
    ?action!mg:hasInput mg:targetWork ?inw .
    ?action mg:hasOutput ?out .
    ?inw mg:hasWorkType ?wt .
    ?inw mg:hasWorkForm ?wf .
    (?action "outputWork") log:skolem ?geniri . # Only one unique output work is created for each train
} => {
    ?out mg:targetWork ?geniri .
    ?geniri a mg:Work ;
        mg:hasWorkType ?wt ;
        mg:hasWorkForm ?wf ;
        mg:hasAuxwork ?inw . # Key difference
} .

##   Generate
# [Generate] Reasoning rules for generate data based on model or algorithm, which adds the 'hasAubwork' property to targetWork,
# and the output work has same type and form as the input target work.
{
    ?action a mg:Generate . # Key difference
    ?action!mg:hasInput mg:targetWork ?inw .
    ?action!mg:hasInput mg:targetWorkForm ?wf . # Use appoint work form and type
    ?action!mg:hasInput mg:targetWorkType ?wt .
    ?action mg:hasOutput ?out .
    (?action "outputWork") log:skolem ?geniri . # Only one unique output work is created for each train
} => {
    ?out mg:targetWork ?geniri .
    ?geniri a mg:Work ;
        mg:hasWorkType ?wt ;
        mg:hasWorkForm ?wf ;
        mg:hasAuxwork ?inw . # Key difference, the input target work is treated as auxwork
} .

##   Publish
# [Publish] Reasoning rules for pulish a work, which
# adds the 'hasMixwork' property to the output.
{
    ?action a mg:Publish .
    ?action!mg:hasInput mg:targetWork ?inw .
    ?action!mg:hasInput mg:targetPublishPolicy ?policy .
    ?action mg:hasOutput ?out .
    ?inw mg:hasWorkType ?wt .
    (?action "outputWork") log:skolem ?geniri . 
} => {
    ?geniri a mg:Work ; # Hold same work form, type, and license info as the input work
        mg:hasMixwork ?inw ;
        mg:hasWorkType ?wt ; # Output has same work type as input
        mg:targetPublishPolicy ?policy . # Add the publish policy to output (republication) work
    ?out mg:targetWork ?geniri .
} .
# [Publish] Assign work form of output
{
    ?action a mg:Publish .
    ?action!mg:hasInput mg:targetWorkForm ?wf .
    ?action!mg:hasOutput mg:targetWork ?outw .
    (?action "outputWork") log:skolem ?geniri . 
} => {
    ?geniri mg:hasWorkForm ?wf . 
} .

# [Publish] IF no work form provided, use the work form of input
{
    ?action a mg:Publish .
    _:x log:notIncludes {?action!mg:hasInput mg:targetWorkForm ?wf }. 
    ?action!mg:hasOutput mg:targetWork ?outw .
    ?action!mg:hasInput!mg:targetWork mg:hasWorkForm ?wf .
    (?action "outputWork") log:skolem ?geniri . 
} => {
    ?geniri mg:hasWorkForm ?wf . 
} .