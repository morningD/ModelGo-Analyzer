@prefix math: <http://www.w3.org/2000/10/swap/math#> .
@prefix list: <http://www.w3.org/2000/10/swap/list#> .
@prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#> .
@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix string: <http://www.w3.org/2000/10/swap/string#> .
@prefix log: <http://www.w3.org/2000/10/swap/log#> .
@prefix mg: <http://www.modelgo.li/rdf/terms#> .
@prefix xsd: <http://www.w3.org/2001/XMLSchema#> .
@prefix : <http://example.org/ns#>.


# Ruling Creation. Add a new ruling to the output work for each action.  
{
    ?actionType rdfs:subClassOf mg:Action . 
    ?actionType log:notEqualTo mg:RegisterLicense . # Skip RegisterLicense
    ?action a ?actionType . # For each action
    ?action!mg:hasInput mg:targetWork ?inw .
    ?inw mg:hasLicense ?linfo . # Ensure that the input work has a license, if not, need to wait for the license determination rules
    ?action!mg:hasOutput mg:targetWork ?outw .
    (?action ?inw ?outw "ruling") log:skolem ?geniri . # Ensure that only one ruling is created for each (action, input work, output work) tuple
} => {
    ?geniri a mg:Ruling ;
        mg:targetWork ?inw ;
        mg:targetAction ?action ;
        mg:hasLicense ?linfo .
    ?outw mg:hasRuling ?geniri .
} .

# Ruling Proliferation. Add a new ruling with the same action to the work's all MIXWORKS
{
    ?actionType rdfs:subClassOf mg:Action . 
    ?ruling a mg:Ruling .
    ?ruling mg:targetAction ?action .   
    # Copy will not proliferate to the mixworks due to the output def no longer being duplication,
    # but we still check the right granting of them by proliferating their request to the mixworks.
    ?actionType log:notEqualTo mg:Copy .
    ?action a ?actionType .
    ?work mg:hasRuling ?ruling .
    ?work mg:hasMixwork ?mixwork .
    ?mixwork mg:hasLicense ?linfo . # The new ruling is according to the license info of the mixwork
    (?action ?mixwork ?work "ruling") log:skolem ?geniri . # Ensure that only one ruling is created for each (action, mixwork, work) tuple
} => {
    ?geniri a mg:Ruling ;
        mg:targetWork ?mixwork ;
        mg:targetAction ?action ;
        mg:hasLicense ?linfo .
    ?work mg:hasRuling ?geniri .
} .

# Ruling Completion. Find the matching LicenseRule for each ruling
{
    ?ruling a mg:Ruling .
    ?ruling mg:hasLicense ?linfo .
    ?linfo mg:hasRule ?rule . # Get the License Rules
    ?ruling!mg:targetWork mg:hasWorkForm ?inwf .
    ?ruling^mg:hasRuling mg:hasWorkForm ?outwf .
    ?ruling mg:targetAction ?action .
    ?rule mg:targetActionType ?atype .
    ?action a ?atype . # Matching action type
    ?rule mg:targetInputWorkForm ?inwf . # Matching input work form
    ?rule mg:targetOutputWorkForm ?outwf . # Matching output work form
    ?rule mg:hasOutputDef ?outputDef . # Find the matching output definition
} => {
    ?ruling mg:hasRule ?rule . # Bind the triggered rule to the ruling
    ?ruling mg:hasOutputDef ?outputDef . # Bind the output definition to the ruling
} .

# License Determination. Find the license of the output work according to its rulings
# The default license in Unlicense, if there are multiple copyleft licenses are triggered, then try to find a compatible license as solution.

{ # CASE-1: All rulings allow relicense output work
    ?outw a mg:Work .
    _:x log:notIncludes { ?outw mg:hasLicense ?li } . # This work does not have a license yet
    # If all relied wroks have a license, we can determind the license of this work
    ( { ?outw mg:hasReliedwork ?relw } { ?relw mg:hasLicense ?li } ) log:forAllIn _:t . 
    
    # If relicense is any-license for all requests
    ({?outw!mg:hasRuling!mg:hasRule mg:relicense ?reli } {?reli log:equalTo mg:any-license}) log:forAllIn _:t .
} => {
    # Use default: Unlicense
    ?outw mg:hasLicense mg:Unlicense .
    ?outw :assign "any-license" .
}.

{ # CASE-2: One of ruling NOT allows relicense output work
    ?outw a mg:Work .
    _:x log:notIncludes { ?outw mg:hasLicense ?li } . # This work does not have a license yet
    # If all relied wroks have a license, we can determind the license of this work
    ( { ?outw mg:hasReliedwork ?relw } { ?relw mg:hasLicense ?li } ) log:forAllIn _:t . 

    # Collect all non-relicensable license to a list
    ( ?li
        { 
            ?outw mg:hasRuling ?rling .
            ?rling!mg:hasRule mg:relicense ?rule .
            ?rule log:equalTo mg:none-license . # None
            ?rling mg:hasLicense ?li .
        }
    ?li_list ) log:collectAllIn _:t .
    ?li_list list:first ?li_first # Select the first non-relicensable license as the license for the output work.
} => {
    ?outw mg:hasLicense ?li_first .
} .
{ # CASE-3: There have multiple rulings require the output work's license should be compatible, but these ruling has a same license
    ?outw a mg:Work .
    _:x log:notIncludes { ?outw mg:hasLicense ?li } . # This work does not have a license yet
    # If all relied wroks have a license, we can determind the license of this work
    ( { ?outw mg:hasReliedwork ?relw } { ?relw mg:hasLicense ?li } ) log:forAllIn _:t . 

    # There is no request that NOT allow relicesnse (For exclude CASE-2)
    ({?outw!mg:hasRuling!mg:hasRule mg:relicense ?reli } {?reli log:notEqualTo mg:none-license}) log:forAllIn _:t .

    # Collect all compatible-relicensable license to a list
    ( ?li
        { 
            ?outw mg:hasRuling ?rling .
            ?rling!mg:hasRule mg:relicense ?rule .
            ?rule log:equalTo mg:compatible-license . # Compatible
            ?rling mg:hasLicense ?li . # This ruling should bind a license which provides a compatible license list
            ?li mg:hasCompatibleLicense ?clist.
        }
    ?li_list ) log:collectAllIn _:t . # (CASE-1 will yield a empty list here) .

    ?li_list list:first ?li_1st .
    ?li_1st mg:hasCompatibleLicense ?compat_list_1st .
    
    # Check wether exist a compatible license from 1st that also in all other (include self) compatible lists
     _:x log:includes 
        {   
            ?cli list:in ?compat_list_1st .
            ({?li_list!list:member mg:hasCompatibleLicense ?compat_list_other} {?cli list:in ?compat_list_other} ) log:forAllIn _:t .
        } .
} => {
    ?outw mg:hasLicense ?li_1st .
} .

############################   Debug: find work that need assign license
# { # All ruling allow relicense output work
#     ?outw a mg:Work .
#     _:x log:notIncludes { ?outw mg:hasLicense ?li } . # This work does not have a license yet
# } => {
#     ?outw :need_assign "license" .
# }.
############################   Debug: find work that is ready to assign license
# { # All ruling allow relicense output work
#     ?outw a mg:Work .
#     _:x log:notIncludes { ?outw mg:hasLicense ?li } . # This work does not have a license yet
#     # If all relied wroks have a license, we can determind the license of this work
#     ( { ?outw mg:hasReliedwork ?relw } { ?relw mg:hasLicense ?li } ) log:forAllIn _:t . 
# } => {
#     ?outw :ready_assign "any-license" .
# }.
############################  Debug: Check wether all work has license
{
    ( {?work a mg:Work} {?work mg:hasLicense ?li} ) log:forAllIn _:t . 
} =>
{
    :license :done_assige 'ok' .
} .