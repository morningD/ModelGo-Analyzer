@prefix math: <http://www.w3.org/2000/10/swap/math#> .
@prefix list: <http://www.w3.org/2000/10/swap/list#> .
@prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#> .
@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix string: <http://www.w3.org/2000/10/swap/string#> .
@prefix log: <http://www.w3.org/2000/10/swap/log#> .
@prefix mg: <http://www.modelgo.li/rdf/terms#> .
@prefix xsd: <http://www.w3.org/2001/XMLSchema#> .
@prefix : <http://example.org/ns#>.


# Ruling Creation. Add a new ruling to the output work for each action.  
{
    ?actionType rdfs:subClassOf mg:Action . 
    ?actionType log:notEqualTo mg:RegisterLicense . # Skip RegisterLicense
    ?action a ?actionType . # For each action
    ?action!mg:hasInput mg:targetWork ?inw .
    ?inw mg:hasLicense ?linfo . # Ensure that the input work has a license, if not, need to wait for the license determination rules
    ?action!mg:hasOutput mg:targetWork ?outw .
    (?action ?inw ?outw "ruling") log:skolem ?geniri . # Ensure that only one ruling is created for each (action, input work, output work) tuple
} => {
    ?geniri a mg:Ruling ;
        mg:targetWork ?inw ;
        mg:targetAction ?action ;
        mg:hasLicense ?linfo .
    ?outw mg:hasRuling ?geniri .
} .

# Ruling Proliferation. Add a new ruling with the same action to the work's all MIXWORKS
{
    ?actionType rdfs:subClassOf mg:Action . 
    ?ruling a mg:Ruling .
    ?ruling mg:targetAction ?action .   
    # Copy will not proliferate to the mixworks due to the output def no longer being duplication,
    # but we still check the right granting of them by proliferating their request to the mixworks.
    ?actionType log:notEqualTo mg:Copy .
    ?action a ?actionType .
    ?work mg:hasRuling ?ruling .
    ?work mg:hasMixwork ?mixwork .
    ?mixwork mg:hasLicense ?linfo . # The new ruling is according to the license info of the mixwork
    (?action ?mixwork ?work "ruling") log:skolem ?geniri . # Ensure that only one ruling is created for each (action, mixwork, work) tuple
} => {
    ?geniri a mg:Ruling ;
        mg:targetWork ?mixwork ;
        mg:targetAction ?action ;
        mg:hasLicense ?linfo .
    ?work mg:hasRuling ?geniri .
} .

# Ruling Completion. Find the matching LicenseRule for each ruling
{
    ?ruling a mg:Ruling .
    ?ruling mg:hasLicense ?linfo .
    ?linfo mg:hasRule ?rule . # Get the License Rules
    ?ruling!mg:targetWork mg:hasWorkForm ?inwf .
    ?ruling^mg:hasRuling mg:hasWorkForm ?outwf .
    ?ruling mg:targetAction ?action .
    ?rule mg:targetActionType ?atype .
    ?action a ?atype . # Matching action type
    ?rule mg:targetInputWorkForm ?inwf . # Matching input work form
    ?rule mg:targetOutputWorkForm ?outwf . # Matching output work form
    ?rule mg:hasOutputDef ?outputDef . # Find the matching output definition
} => {
    ?ruling mg:hasRule ?rule . # Bind the triggered rule to the ruling
    ?ruling mg:hasOutputDef ?outputDef . # Bind the output definition to the ruling
} .

# License Determination. Find the license of the output work according to its rulings
# The default license in Unlicense, if there are multiple copyleft licenses are triggered, then try to find a compatible license as solution.
# NOTE: The found solution may not be valid. We assign the license as compliantly as possible to enable further analysis; any corresponding errors will be reported during the analysis phase.

# We use these LicenseSource to record the reason of a license determination, this source infomation can be used in further reporting.
mg:license_source_ruling_relicense_pass a mg:LicenseSource . # All relied licenses allow relicensing, default license is used (e.g., Unlicense).
mg:license_source_ruling_relicense_fail a mg:LicenseSource . # There have multiple licenses unallow relicesing, one of non-relicensable license is used.
mg:license_source_ruling_copyleft_pass a mg:LicenseSource . # There have multiple licenses that require a compatible assignment and a solution can be found by ruling.
mg:license_source_ruling_copyleft_fail a mg:LicenseSource . # There have multiple licenses that require a compatible assignment and NO solution can be found by ruling.

{ # CASE-0: If the expected license provided, use this license for output work (may invalid)
    ?outw a mg:Work .
    _:x log:notIncludes { ?outw mg:hasLicense ?li } . # This work does not have a license yet
    ?outw mg:hasExpectedLicense ?li .
} => {
    # Use expected license
    ?outw mg:hasLicense ?li ;
        mg:hasLicenseSource mg:license_source_user_expect .
} .

{ # CASE-1: All rulings allow relicense output work. (any, any) -> Unlicense
    ?outw a mg:Work .
    _:x log:notIncludes { ?outw mg:hasLicense ?li } . # This work does not have a license yet
    # If all relied wroks have a license, we can determind the license of this work
    ( { ?outw mg:hasReliedwork ?relw } { ?relw mg:hasLicense ?li } ) log:forAllIn _:t . 
    
    # If relicense is any-license for all requests
    ({?outw!mg:hasRuling!mg:hasRule mg:relicense ?reli } {?reli log:equalTo mg:any-license}) log:forAllIn _:t .
    _:t log:notIncludes { ?outw mg:hasExpectedLicense ?li } .
} => {
    # Use default: Unlicense
    ?outw mg:hasLicense mg:Unlicense ;
        mg:hasLicenseSource mg:license_source_ruling_relicense_pass .
} .

{ # CASE-2: One of ruling NOT allows relicense output work. (none, any/compat) -> none
    ?outw a mg:Work .
    _:x log:notIncludes { ?outw mg:hasLicense ?li } . # This work does not have a license yet
    # If all relied wroks have a license, we can determind the license of this work
    ( { ?outw mg:hasReliedwork ?relw } { ?relw mg:hasLicense ?li } ) log:forAllIn _:t . 

    # Collect all non-relicensable license to a list
    ( ?li
        { 
            ?outw mg:hasRuling ?rling .
            ?rling!mg:hasRule mg:relicense ?rule .
            ?rule log:equalTo mg:none-license . # None
            ?rling mg:hasLicense ?li .
        }
    ?li_list ) log:collectAllIn _:t .
    ?li_list list:first ?li_first # Select the first non-relicensable license as the license for the output work.
} => {
    ?outw mg:hasLicense ?li_first ;
        mg:hasLicenseSource mg:license_source_ruling_relicense_fail .
} .

{ # CASE-3: There have multiple rulings require the output work's license should be compatible, and these ruling has a same (compatible) license. (compat1, compat2) -> compat
    ?outw a mg:Work .
    _:x log:notIncludes { ?outw mg:hasLicense ?li } . # This work does not have a license yet
    # If all relied wroks have a license, we can determind the license of this work
    ( { ?outw mg:hasReliedwork ?relw } { ?relw mg:hasLicense ?li } ) log:forAllIn _:t . 

    # There is no ruling that NOT allow relicesnse (For exclude CASE-2)
    ( {?outw!mg:hasRuling!mg:hasRule mg:relicense ?reli } {?reli log:notEqualTo mg:none-license} ) log:forAllIn _:t .

    # Collect all compatible-relicensable license to a list
    ( ?li
        { 
            ?outw mg:hasRuling ?rling .
            ?rling!mg:hasRule mg:relicense ?rule .
            ?rule log:equalTo mg:compatible-license . # Compatible
            ?rling mg:hasLicense ?li . # This ruling should bind a license which provides a compatible license list
            ?li mg:hasCompatibleLicense ?clist.
        }
    ?li_list ) log:collectAllIn _:t . # (CASE-1 will yield a empty list here).

    ?li_list list:first ?li_1st .
    ?li_1st mg:hasCompatibleLicense ?compat_list_1st .
    
    # Check wether exist a compatible license from 1st that also in all other (include self) compatible lists
    _:x log:includes # Return true if there is a license included in all compatible list.
        {   
            ?cli list:in ?compat_list_1st .
            ( {?li_list!list:member mg:hasCompatibleLicense ?compat_list_other} {?cli list:in ?compat_list_other} ) log:forAllIn _:t .
        } .
} => {
    ?outw mg:hasLicense ?cli ;
        mg:hasLicenseSource mg:license_source_ruling_copyleft_pass .
} .

{ # CASE-4: There have multiple rulings require the output work's license should be compatible, and no compatible solution exist. (incompat1, incompat2) -> incompat
    ?outw a mg:Work .
    _:x log:notIncludes { ?outw mg:hasLicense ?li } . # This work does not have a license yet
    # If all relied wroks have a license, we can determind the license of this work
    ( { ?outw mg:hasReliedwork ?relw } { ?relw mg:hasLicense ?li } ) log:forAllIn _:t . 

    # There is no ruling that NOT allow relicesnse (For exclude CASE-2)
    ({?outw!mg:hasRuling!mg:hasRule mg:relicense ?reli } {?reli log:notEqualTo mg:none-license}) log:forAllIn _:t .

    # Collect all compatible-relicensable license to a list
    ( ?li
        { 
            ?outw mg:hasRuling ?rling .
            ?rling!mg:hasRule mg:relicense ?rule .
            ?rule log:equalTo mg:compatible-license . # Compatible
            ?rling mg:hasLicense ?li . # This ruling should bind a license which provides a compatible license list
            ?li mg:hasCompatibleLicense ?clist.
        }
    ?li_list ) log:collectAllIn _:t . # (CASE-1 will yield a empty list here) .

    ?li_list list:first ?li_1st .
    ?li_1st mg:hasCompatibleLicense ?compat_list_1st .
    
    # Check wether exist a compatible license from 1st that also in all other (include self) compatible lists
     _:x log:notIncludes # (CASE-3 will yield false here), return true if there is not a license included in all compatible list.
        {   
            ?cli list:in ?compat_list_1st .
            ( {?li_list!list:member mg:hasCompatibleLicense ?compat_list_other} {?cli list:in ?compat_list_other} ) log:forAllIn _:t .
        } .
} => {
    ?outw mg:hasLicense ?cli ;
        mg:hasLicenseSource mg:license_source_ruling_copyleft_fail .
} .
